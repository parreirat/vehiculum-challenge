#!/usr/bin/env ruby

# Runs our .gemspec, among others, allowing 'lib' to be appended onto $LOAD_PATH
require "bundler/setup"

require "thor"
require "awesome_print"

require "pry"
require "pry-byebug"
require "pry-doc"

require "status"

class StatusCLI < Thor

  desc "pull [--no-output]", "queries services once and saves into data store"
  method_option :webpages, type: :array, default: Status::Page.implemented_pages
  method_option :output  , type: :boolean, default: true
  def pull
    # @parreirat NOTE - Need top-level orchestrator class... not calling
    #   these internals directly!
  	Thread.new {
      page = Status::Pages::Bitbucket.new
      puts "Pooling #{page.provider}...".yellow if options[:output]
      is_up = page.is_up?(true)
      if options[:output]
      status = ""
        if is_up
          status = "Up!".to_s.green
        else
          status = "Down!".to_s.red
        end
      puts "Pooling #{page.provider} complete: #{status}".yellow
      end
	  }.join
  end

  # @parreirat NOTE - Some yield magic somewhere around here?
	# Optional param webpages: all, subset (default: all)
	desc "live [--pool_interval=5] [--no-output] ", "queries services continuously with pool_interval seconds interval and saves into store"
  method_option :pool_interval, type: :numeric, default: 1
  method_option :output, type: :boolean, default: true
	def live
    # @parreirat NOTE - Should rescue Timeout::Error and SocketError.
    begin
      puts "\n---===# Press ctrl+c to quit! #===---\n".yellow
      loop do
        Thread.new {
          page = Status::Pages::Bitbucket.new
          puts "Pooling #{page.provider}...".yellow if options[:output]
          is_up = page.is_up?(true)
          if options[:output]
            status = ""
            if is_up
              status = "Up!".to_s.green
            else
              status = "Down!".to_s.red
            end
            puts "Pooling #{page.provider} complete: #{status}".yellow
          end
        }.join
        puts "Waiting #{options[:pool_interval]} seconds before pooling again...".yellow  if options[:output]
        sleep(options[:pool_interval])
      end
    rescue Interrupt
      puts "\n---===# status live has terminated! #===---\n".green
    end
	end

  desc "history [--format=standard_table]", "prints all the data currently saved"
  method_option :format, type: :string, default: "standard_table"
	def history
    data_store = Status::DataStore.new
    history = Status::History.new(data_store)
    history.print(options[:format])
	end

  desc "backup [--file=backup_data_store.csv]", "saves current status data to a file"
  method_option :file, type: :string, default: "backup_data_store.csv"
	def backup
    data_store = Status::DataStore.new
    data_store.save_data_store(options[:file])
	end

  method_option :file, type: :string, default: "backup_data_store.csv"
  method_option :merge, type: :boolean, default: :true
	desc "restore [--file=backup_data_store.csv] [--merge=true]", "adds data from a file into current status data"
	def restore
    if options[:merge]
      data_store = Status::DataStore.new
      data_store.load_data_store(options[:file])
      puts "Merged data from '#{options[:file]}' into data store.".green
    else
      data_store = Status::DataStore.new(false)
      data_store.load_data_store(options[:file])
      puts "Replaced data store with data from '#{options[:file]}'.".green
    end
	end

  # @parreirat NOTE - Not required but is useful.
  desc "reset", "deletes the data store"
  def reset
    Status::DataStore.new.wipe_data_store
    puts "Wiped data store!".green
  end

	desc "stats","summarizes the current data and prints it"
	def stats
	end

end

StatusCLI.start(ARGV)